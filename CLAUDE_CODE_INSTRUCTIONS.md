# Transferring MIDI Curator to Claude Code & Plugin Development Path

## Quick Transfer to Claude Code

### Step 1: Start a New Session in Claude Code

Open your terminal and navigate to where you want the project:

```bash
cd ~/projects
mkdir midi-curator-app
cd midi-curator-app
```

### Step 2: Provide This Context to Claude Code

Copy and paste this into Claude Code:

```
I have a React-based MIDI curator web app that I want to turn into a standalone 
desktop application. Here's what it does:

FEATURES:
- Imports MIDI files, parses them into gesture (rhythm) + harmonic (pitch) layers
- Stores clips in IndexedDB with tags, ratings, BPM
- Transforms patterns by adjusting density (0.25x to 2.0x)
- Generates variants with different note counts
- Exports as MIDI files or ZIP archives
- Uses pure JavaScript (no external dependencies for MIDI/ZIP)

ARCHITECTURE:
- Two-layer model: gesture (onsets, durations, velocities) + harmonic (pitches)
- IndexedDB for local storage
- Pure JS MIDI parser and exporter
- Pure JS ZIP creator

I'll provide the React artifact code. Please help me:
1. Set up a proper Vite + React project structure
2. Add file system support for easier MIDI import/export
3. Eventually prepare for Electron packaging or native plugin development

Here's the current React artifact code:
[paste the midi-curator.jsx code]

And here's the documentation:
[paste MIDI_CURATOR_DOCS.md]
```

### Step 3: Files Claude Code Should Create

Claude Code will likely create:

```
midi-curator-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ vite.config.js
â”œâ”€â”€ index.html
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.jsx                 # Entry point
â”‚   â”œâ”€â”€ App.jsx                  # Main component (from artifact)
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ midi-parser.js       # MIDI parsing functions
â”‚   â”‚   â”œâ”€â”€ midi-export.js       # MIDI export functions
â”‚   â”‚   â”œâ”€â”€ zip-creator.js       # Pure JS ZIP
â”‚   â”‚   â”œâ”€â”€ db.js                # IndexedDB wrapper
â”‚   â”‚   â”œâ”€â”€ gesture.js           # Gesture extraction/transform
â”‚   â”‚   â””â”€â”€ harmonic.js          # Harmonic functions
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Sidebar.jsx
â”‚   â”‚   â”œâ”€â”€ ClipDetail.jsx
â”‚   â”‚   â”œâ”€â”€ TransformControls.jsx
â”‚   â”‚   â””â”€â”€ PianoRoll.jsx        # TODO: Add this next
â”‚   â””â”€â”€ hooks/
â”‚       â”œâ”€â”€ useDatabase.js
â”‚       â””â”€â”€ useMIDI.js
â””â”€â”€ README.md
```

---

## Development Path Options

### Option A: Vite + React (Desktop via Electron) â­ RECOMMENDED

**Best for**: Quick iteration, cross-platform desktop app

**Pros**:
- Keep existing React code
- Add Node.js file system access
- Package as native-looking desktop app
- Cross-platform (macOS, Windows, Linux)

**Cons**:
- Can't be AUv3 plugin (Electron too heavy)
- Larger bundle size

**Next Steps**:
1. Ask Claude Code to set up Vite + React project
2. Add Electron when ready: `npm install -D electron electron-builder`
3. Add IPC for file system operations
4. Package for distribution

**Timeline**: 1-2 sessions to get working desktop app

---

### Option B: Native Plugin (JUCE Framework) ğŸµ

**Best for**: AUv3, VST3, AU plugin development

**Why JUCE**:
- Industry-standard C++ framework for audio plugins
- Compiles to VST3, AU, AUv3, AAX, Standalone
- Built-in MIDI handling
- Works on macOS, iOS, Windows, Linux

**Major Change**:
- **Can't use React** (JUCE has its own UI framework)
- Need to rewrite in C++
- Steeper learning curve

**Architecture Translation**:
```
React State â†’ JUCE ValueTree
IndexedDB â†’ XML/JSON files or SQLite
React Components â†’ JUCE Components
Canvas â†’ JUCE Graphics
```

**JUCE Structure**:
```
MidiCurator/
â”œâ”€â”€ Source/
â”‚   â”œâ”€â”€ PluginProcessor.h/cpp      # Audio processing
â”‚   â”œâ”€â”€ PluginEditor.h/cpp         # UI
â”‚   â”œâ”€â”€ MidiParser.h/cpp           # Parse MIDI
â”‚   â”œâ”€â”€ GestureEngine.h/cpp        # Transform logic
â”‚   â”œâ”€â”€ ClipDatabase.h/cpp         # Storage
â”‚   â””â”€â”€ Components/
â”‚       â”œâ”€â”€ ClipList.h/cpp
â”‚       â”œâ”€â”€ PianoRoll.h/cpp
â”‚       â””â”€â”€ TransformControls.h/cpp
â”œâ”€â”€ MidiCurator.jucer              # Project file
â””â”€â”€ Builds/                        # Generated by Projucer
```

**Timeline**: 4-6 sessions minimum (if you know C++)

---

### Option C: Hybrid Approach ğŸ¯ PRAGMATIC

**Best for**: Getting working tool now, plugin later

**Phase 1**: Desktop App (Electron)
- Build full-featured Electron app
- Get all features working
- Use in your workflow

**Phase 2**: Plugin Core in C++
- Extract core algorithms (gesture transform, MIDI parsing)
- Rewrite as C++ library
- Test extensively

**Phase 3**: JUCE Plugin
- Build JUCE plugin around C++ core
- Recreate UI in JUCE
- Focus on workflow integration

**Timeline**: 
- Phase 1: 2-3 sessions
- Phase 2: 3-4 sessions
- Phase 3: 4-6 sessions

---

## Specific Instructions for Claude Code

### Session 1: Project Setup

```
Set up a new Vite + React + TypeScript project for MIDI Curator.

Requirements:
- Use Vite for fast dev server
- TypeScript for type safety
- React 18
- No external MIDI libraries (we have pure JS implementations)

Structure:
- Separate lib/ folder for pure functions
- Components folder for React UI
- Keep IndexedDB wrapper modular

Install these only:
- React, ReactDOM
- Vite
- TypeScript

Don't install:
- tone.js (not yet)
- midi libraries (we have pure JS)
- UI frameworks (custom CSS is fine)
```

### Session 2: Add File System

```
Add Electron support to enable:
- Drag & drop folders (not just files)
- Batch import from directory
- Export to user-selected location
- Remember last import/export paths

Use Electron IPC for:
- Main process: File system operations
- Renderer process: React UI

Setup:
- electron-builder for packaging
- electron-store for preferences
- Standard IPC channels
```

### Session 3: Add Playback

```
Add WebAudio-based MIDI playback:

Requirements:
- Use Tone.js for synthesis
- Simple sine wave sound is fine
- Transport controls (play/pause/stop)
- Visual playhead in sidebar
- Keyboard shortcut: Space to play/pause

Implementation:
- Tone.Transport for scheduling
- Schedule all notes from gesture + harmonic
- Update UI during playback
```

### Session 4: Add Piano Roll

```
Add canvas-based piano roll visualization:

Features:
- Mini view in sidebar (100x50px per clip)
- Large view when selected (full width)
- Zoom controls (horizontal and vertical)
- Highlight on hover
- Optional: Click to select notes (future editing)

Drawing:
- Canvas API
- X-axis: time (ticks â†’ pixels)
- Y-axis: pitch (MIDI note â†’ pixels)
- Draw notes as rectangles
- Color by velocity
```

---

## For AUv3 Plugin Development

### Prerequisites

You'll need:
- **macOS** (for iOS/macOS plugin development)
- **Xcode** (free from App Store)
- **JUCE framework** (free, open source)
- **C++ knowledge** (or willingness to learn)

### JUCE Setup

1. Download JUCE from juce.com
2. Run Projucer (JUCE's project manager)
3. Create new "Audio Plug-In" project
4. Configure:
   - Plugin formats: AUv3, VST3, Standalone
   - Plugin code: `MidiCurator`
   - MIDI Effect: Yes
   - MIDI Input: Yes
   - MIDI Output: Yes

### Core Logic to Port

**Priority 1**: MIDI parser and exporter (pure algorithms)
```cpp
class MidiParser {
public:
    struct Note {
        int pitch;
        int onset;
        int duration;
        int velocity;
    };
    
    std::vector<Note> parse(const juce::MidiFile& file);
    juce::MidiFile exportToMidi(const std::vector<Note>& notes, int bpm);
};
```

**Priority 2**: Gesture transform
```cpp
class GestureTransform {
public:
    struct Gesture {
        std::vector<int> onsets;
        std::vector<int> durations;
        std::vector<int> velocities;
        float density;
    };
    
    Gesture adjustDensity(const Gesture& input, float multiplier);
    Gesture quantize(const Gesture& input, float strength);
};
```

**Priority 3**: UI components
```cpp
class ClipList : public juce::Component {
    // List of clips in sidebar
};

class PianoRoll : public juce::Component {
    void paint(juce::Graphics& g) override {
        // Draw piano roll
    }
};
```

### Ask Claude Code

```
I want to start building a JUCE audio plugin based on my MIDI Curator app.

First, help me set up:
1. JUCE project structure
2. Basic plugin processor (MIDI in/out)
3. Port the MIDI parser from JavaScript to C++
4. Port the gesture transform algorithm to C++

We'll build the UI later. Focus on getting the core algorithms working first.

Here's my current JavaScript implementation:
[paste relevant functions]
```

---

## Recommended Timeline

### Week 1-2: Desktop App
- Get Electron app working
- All features from artifact
- File system integration
- Use daily in your workflow

### Week 3-4: Polish Desktop App
- Add playback
- Add piano roll
- Add more transforms
- Refine UX

### Month 2: Evaluate Plugin Need
- Is desktop app sufficient?
- Do you need DAW integration?
- Would standalone host work?

### Month 3+: Plugin Development
- Start JUCE learning
- Port core algorithms
- Build plugin UI
- Test in DAW

---

## Key Decision: Electron vs. JUCE

### Choose Electron if:
âœ… You want fast iteration  
âœ… You're comfortable with React/JS  
âœ… Desktop app is the main use case  
âœ… Cross-platform is important  
âœ… You want to ship something this month  

### Choose JUCE if:
âœ… You need DAW integration  
âœ… You need AUv3/VST3/AU  
âœ… You're willing to learn C++  
âœ… Audio performance is critical  
âœ… You want to ship a commercial plugin  

### My Recommendation: START WITH ELECTRON

Build the Electron app first because:
1. You already have working code
2. You'll discover what features matter most
3. You can use it immediately
4. You can always port to JUCE later
5. The core algorithms (gesture transform) are portable

---

## Files to Give Claude Code

### Essential:
1. **midi-curator.jsx** - Current working code
2. **MIDI_CURATOR_DOCS.md** - Full documentation
3. **This file** - Transfer instructions

### Tell Claude Code:
```
I want to turn this React artifact into a standalone desktop app using 
Electron. Let's start with:

1. Proper project structure (Vite + React + TypeScript)
2. Break the monolithic component into modules
3. Add Electron for file system access
4. Keep all the pure JS MIDI/ZIP functions

Goal: A polished desktop app I can use daily for MIDI curation.

Future goal: Eventually port to JUCE for AUv3 plugin, but not yet.

Here's the current code: [paste files]
```

---

## What Claude Code Will Do

**Session 1**: Project structure
- Set up package.json, vite.config, tsconfig
- Create proper folder structure
- Move code into modules
- Get it running locally

**Session 2**: Features
- Fix any bugs from refactor
- Add requested features (playback, piano roll)
- Improve UX

**Session 3**: Electron
- Add main process
- IPC for file operations
- Build and package

**Session 4**: Polish
- Icons, about screen
- Keyboard shortcuts help
- Error handling
- Testing

After that, you'll have a working desktop app!

---

## For Your Next Claude Code Session

**Copy this prompt**:

```
I have a React-based MIDI curator tool that I want to turn into a 
proper desktop application.

WHAT IT DOES:
- Imports MIDI files and analyzes them (gesture + harmonic layers)
- Transforms patterns by adjusting density, quantization, velocity
- Generates variants and exports as MIDI or ZIP
- Stores everything in IndexedDB

CURRENT STATE:
- Working React artifact (single file)
- Pure JavaScript MIDI parser/exporter
- Pure JavaScript ZIP creator
- No external dependencies for core functionality

GOAL:
Set up a proper Vite + React + TypeScript project with:
- Clean module structure (lib/, components/, hooks/)
- Type safety
- Better file organization
- Easy to extend

FUTURE:
- Add Electron for desktop app
- Eventually port to JUCE for AUv3 plugin

I'll paste the current code and documentation. Please:
1. Create proper project structure
2. Split monolithic component into modules
3. Add TypeScript types
4. Set up dev environment
5. Make sure it runs

Ready? Here's the code:

[paste midi-curator.jsx]
[paste MIDI_CURATOR_DOCS.md]
```

That's it! Claude Code will take it from there.
